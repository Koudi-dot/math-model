# Лабораторная работа: Визуализация водной поверхности в OpenGL

## Задание

Требуется написмать программу, отображающую в реальном масштабе времени
водную поверхность в качестве как можно более близком к фотореалистичному.

*Исходные данные:* Водная поверхность задается функцией высот $h(x,y;t)$
точек над неким нулевым уровнем в момент времени $t$,
т.е. точки поверхности имеют координаты $(x,y,h(x,y;z))$.
Координаты $(x,y)$ пробегают прямоугольную решетку,

$$x_K=2\frac{k}{N_x}-1,y_j=2\frac{j}{N_y}-1,$$

где $N_x$ и $N_y$ - число точек решетки по каждой из осей,
диапазон изменения координат $-1\leq x,y,\leq 1$.
Программа получает на вход массив значений высоты
$h_{jk}=h(x_k,h_j;t)$ для каждого момента времени.
Для тестирования кода можно предположить, 
что колебания поверхности образуются суммой плоских
волн со случайными параметрами $A_n$ - амплитуда,
$k_n$ - волновой вектор, $\omega$ - частота, 
$\phi$ - фаза:

$$h(x,y;t)=\sum_n A_n\cos(k_{n,x}x+k_{n,y}y+\omega t+\phi).$$

В следующей лабораторной мы будем генерировать 
высоты более реалистично, но для отрисовки будем
использовать код из этой лабораторной.

*Результатом выполнения программы* должно быть 
анимированное изображение водной поверхности на экране.
Время построения одного кадра не должно превосходить 
0.1 секунды для решетки размера $100\times 100$.
Качество изображения должно быть приближено к 
фотореалистическому.

*Ход выполнения работы.* 
Выполнение работы разбито на этапы, 
для минимального выполнения работы неообходимо выполнить
8 этапов.
Для получения максимального числа баллов необходимо
выполнить 11 этапов, бальная стоимость всех этапов одинакова.

1 этап, [Python](render1.py). 
Создать окно приложения, контекст OpenGL.
Очистить фон и отрисовать одну точку.

2 этап, [Python](render2.py). 
Подготовить массив данных для отрисовки, 
обновлять массив по таймеру.
Отрисовать точки решетки на водной поверхности.
Сделать анимацию.
Положение камеры считать фиксированным: 
камера смотрит на воду сверху, 
перпендикулярно поверхности.

3 этап, [Python](render3.py). 
Отрисовать отрезки, соединяющие соседние 
узлы решетки (wireframe).
Убедиться в корректности изображения перспективы. 

4 этап, [Python](render4.py). Построить триангуляцию поверхности,
отрисовать треугольники. Реализовать вычисление
цвета отдельных точек треугольинка. 
Отрисовать [тепловую карту](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BF%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BA%D0%B0%D1%80%D1%82%D0%B0) высот.

5 этап, [Python](render5b.py). Вычислить нормали к водной поверхности.
Реализовать [затенение по Фонгу](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%82%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%A4%D0%BE%D0%BD%D0%B3%D1%83) с одним направленным источником света
(Солнце) и рассеянным светом.

6 этап, [Python](render6.py). Загрузить текстуру неба.
Отрисовать отражение неба от водной поверхности.

7 этап, [Python](render7.py). Загрузить текстуру дна.
Вычислить преломленные лучи, найти точки пересечения
со дном и соответствующие координаты на текстуре.
Отрисовать дно, как его видно сквозь водную поверхность.
Дно считать плоским, расположенным параллельно
спокойной водно поверхности.

8 этап, [Python](render8.py). Реализовать вращение камеры.
Отрисовать сцену для произвольного положения камеры.
Получить изображение [солнечной дорожки](https://www.shutterstock.com/video/clip-4867919-stock-footage-sunset-sea.html).

9 этап, [WebGL](render9.html). Учесть изменение цвета воды с увеличением глубины.

10 этап, [WebGL](render10.html). Реализовать корректную отрисовку сцены
для положения камеры под водой.

11 этап, [WebGL](render11.html). Реализовать отрисовку неба, использовать его
как фон для водной глади. 
Согласовать изображение неба и его отражение.

12 этап, [WebGL](render12.html). Динамически вычислять и отрисовывать 
[каустики](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%83%D1%81%D1%82%D0%B8%D0%BA%D0%B0) 
в реальном масштабе времени.

13 этап. Не передавать нормали к поверхности,
а рассчитывать их в OpenGL через положения вершин.

14 этап. Реализовать ночной режим с отрисовкой
отражения звезд.

15 этап. Отрисовать сцену для неровного дна,
форма которого задана массивом высот точек дна.

## Рекомендуемые программные средства
Использование Python с библиотекой 
[VisPy](http://vispy.org) 
позволит вам избежать решение множества технических
сложностей и сосредоточиться на сути работы.
Также вам будет полезна библиотека для работы
с многомерными массивами 
[NumPy](http://www.numpy.org/).

## Литература

### Книги

1. [OpenGL SuperBible](http://www.openglsuperbible.com/).
Если вы пользуйтесь VisPy, то вам потребуется
[четвертая редакция](https://www.google.ru/search?q=opengl+superbible+4th+edition+pdf), 
описывающая OpenGL 2.1.

1. [3D Computer Graphics: A Mathematical Introduction with OpenGL](https://www.google.ru/search?q=3d+computer+graphics+a+mathematical+introduction+with+opengl+pdf)

1. [Real-Time Rendering](http://www.realtimerendering.com/)

1. [Computer Graphics: Principles and Practice](http://dept.cs.williams.edu/~morgan/cgpp/about.xml)

### Примеры кода

1. Комментарии к примерам выполнения первых 5 этапов лабораторной, 
см. ссылки выше.

1. Исходнинки [примеров](http://vispy.org/gallery.html) 
программ с использованием VisPy.


